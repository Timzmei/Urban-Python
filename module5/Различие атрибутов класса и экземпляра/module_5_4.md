## Цель: понять разницу между атрибутами объекта и класса, дополнив уже существующий класс. Применить метод __new__.

### Дополнительно о работе метода ***\_\_new__***:
Как мы уже знаем метод ***\_\_new__*** вызывается перед тем, как вызовется метод ***\_\_init__***.
Разберёмся, как происходит передача данных между ними на следующем примере:

```python
class Example:
  def __new__(cls, *args, **kwargs):
    print(args)
    print(kwargs)
    return object.__new__(cls)

  def __init__(self, first, second, third):
    print(first)
    print(second)
    print(third)

ex = Example('data', second=25, third=3.14)
```
### Работа ***\_\_new__***:
1. **'data'** передаётся (упаковывается) в **\*args**, т.к. это позиционный аргумент. Он будет находиться под индексом **0** как единственный элемент кортежа.
2. **second=25** и **third=3.14** передаются (упаковываются) в **\*\*kwargs** т.к. это именованные аргументы. Они будут находиться под ключами **'second'** и **'third'** со значением **25** и **3.14** соответственно в словаре.
### Передача данных из ***\_\_new__*** в ***\_\_init__***:
После того как метод ***\_\_new__*** отработает до конца, произойдут следующие события с параметрами ***\_\_init__***:
1. В параметр **first** распакуется из args единственный аргумент **'data'**.
2. В параметр **second** распакуется значение под ключом с тем же названием из словаря **kwargs**.
3. В параметр **third** распакуется значение под ключом с тем же названием из словаря **kwargs**.


## Задача "История строительства":
Для решения этой задачи будем пользоваться решением к предыдущей задаче <u>"Перегрузка операторов"</u>.

В классе **House** создайте атрибут **houses_history = []**, который будет хранить названия созданных объектов.

Правильней вписывать здание в историю сразу при создании объекта, тем более можно удобно обращаться к атрибутам класса используя ссылку на сам класс - ***cls***.

Дополните метод ***\_\_new__*** так, чтобы:
1. Название объекта добавлялось в список **cls.houses_history**.
2. Название строения можно взять из **args** по индексу.

Также переопределите метод ***\_\_del__(self)*** в котором будет выводиться строка:
**"<название> снесён, но он останется в истории"**

Создайте несколько объектов класса **House** и проверьте работу методов ***\_\_del__*** и ***\_\_new__***, а также значение атрибута **houses_history**.

### Пример результата выполнения программы:
Пример выполнения программы:
```python
h1 = House('ЖК Эльбрус', 10)
print(House.houses_history)
h2 = House('ЖК Акация', 20)
print(House.houses_history)
h3 = House('ЖК Матрёшки', 20)
print(House.houses_history)

# Удаление объектов
del h2
del h3

print(House.houses_history)
```
Вывод на консоль:
```
['ЖК Эльбрус']
['ЖК Эльбрус', 'ЖК Акация']
['ЖК Эльбрус', 'ЖК Акация', 'ЖК Матрёшки']
ЖК Акация снесён, но он останется в истории
ЖК Матрёшки снесён, но он останется в истории
['ЖК Эльбрус', 'ЖК Акация', 'ЖК Матрёшки']
ЖК Эльбрус снесён, но он останется в истории
```
Примечания:
1. Более подробно о работе метода ***\_\_new__*** можно узнать [здесь](https://docs.python.org/3/reference/datamodel.html#object.__new__).
2. В методе ***\_\_new__*** можно обращаться к атрибутам текущего класса при помощи параметра **cls**.